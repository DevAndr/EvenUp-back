// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../node_modules/.prisma/client"
  output   = "../src/generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// â”€â”€â”€ Enums â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum GroupStatus {
  ACTIVE
  SETTLED
  ARCHIVED
}

enum SplitType {
  EQUAL
  CUSTOM
}

enum CategoryId {
  FOOD
  TAXI
  GROCERY
  HOME
  MUSIC
  PLANE
  OTHER
}

enum SettlementStatus {
  PENDING
  CONFIRMED
}

// â”€â”€â”€ Models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ â€” Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·ÑƒĞµÑ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· Telegram
model User {
  id         String   @id @default(cuid())
  telegramId BigInt   @unique @map("telegram_id")
  name       String
  username   String?
  phone      String?
  avatarUrl  String?  @map("avatar_url")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  ownedGroups         Group[]       @relation("GroupOwner")
  memberships         GroupMember[]
  paidExpenses        Expense[]     @relation("ExpensePayer")
  sentSettlements     Settlement[]  @relation("SettlementFrom")
  receivedSettlements Settlement[]  @relation("SettlementTo")

  @@map("users")
}

/// Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ñ€Ğ°ÑÑ…Ğ¾Ğ´Ğ¾Ğ² (Ğ¿Ğ¾ĞµĞ·Ğ´ĞºĞ°, ĞºĞ²Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ°, ĞºĞ¾Ñ€Ğ¿Ğ¾Ñ€Ğ°Ñ‚Ğ¸Ğ² Ğ¸ Ñ‚.Ğ´.)
model Group {
  id          String      @id @default(cuid())
  name        String
  emoji       String      @default("ğŸ‰")
  description String?
  splitType   SplitType   @default(EQUAL) @map("split_type")
  status      GroupStatus @default(ACTIVE)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Owner
  ownerId String @map("owner_id")
  owner   User   @relation("GroupOwner", fields: [ownerId], references: [id])

  // Relations
  members     GroupMember[]
  expenses    Expense[]
  settlements Settlement[]

  @@map("groups")
}

/// Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ (ÑĞ²ÑĞ·ÑŒ User â†” Group)
model GroupMember {
  id       String   @id @default(cuid())
  joinedAt DateTime @default(now()) @map("joined_at")

  groupId String @map("group_id")
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@map("group_members")
}

/// Ğ¢Ñ€Ğ°Ñ‚Ğ° Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ
model Expense {
  id          String     @id @default(cuid())
  description String
  amount      Decimal    @db.Decimal(12, 2)
  category    CategoryId @default(OTHER)
  date        DateTime   @default(now())
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")

  // ĞšÑ‚Ğ¾ Ğ·Ğ°Ğ¿Ğ»Ğ°Ñ‚Ğ¸Ğ»
  paidById String @map("paid_by_id")
  paidBy   User   @relation("ExpensePayer", fields: [paidById], references: [id])

  // Ğš ĞºĞ°ĞºĞ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ÑÑ
  groupId String @map("group_id")
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // ĞœĞµĞ¶Ğ´Ñƒ ĞºĞµĞ¼ Ğ´ĞµĞ»Ğ¸Ñ‚ÑÑ
  splits ExpenseSplit[]

  @@map("expenses")
}

/// Ğ”Ğ¾Ğ»Ñ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ² ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¹ Ñ‚Ñ€Ğ°Ñ‚Ğµ
model ExpenseSplit {
  id     String  @id @default(cuid())
  amount Decimal @db.Decimal(12, 2) // ÑÑƒĞ¼Ğ¼Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑÑ‚Ğ¾Ñ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº

  expenseId String  @map("expense_id")
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  userId String @map("user_id")

  // userId Ğ½Ğµ FK Ğ½Ğ° User Ğ½Ğ°Ğ¼ĞµÑ€ĞµĞ½Ğ½Ğ¾ â€” ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ¼Ğ¾Ğ³ Ğ¿Ğ¾ĞºĞ¸Ğ½ÑƒÑ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ,
  // Ğ½Ğ¾ ĞµĞ³Ğ¾ Ğ´Ğ¾Ğ»Ñ Ğ² Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒÑÑ
  @@unique([expenseId, userId])
  @@map("expense_splits")
}

/// ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ³Ğ°
model Settlement {
  id        String           @id @default(cuid())
  amount    Decimal          @db.Decimal(12, 2)
  status    SettlementStatus @default(PENDING)
  note      String?
  createdAt DateTime         @default(now()) @map("created_at")
  settledAt DateTime?        @map("settled_at")

  groupId String @map("group_id")
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  fromUserId String @map("from_user_id")
  fromUser   User   @relation("SettlementFrom", fields: [fromUserId], references: [id])

  toUserId String @map("to_user_id")
  toUser   User   @relation("SettlementTo", fields: [toUserId], references: [id])

  @@map("settlements")
}
